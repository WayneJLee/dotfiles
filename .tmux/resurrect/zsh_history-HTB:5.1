readlink -f words | xclip -sel c
vim bruteforce.pl
perl bruteforce.pl creds.txt
perl bruteforce.pl file
ls -la
hexdump creds.txt
hexdump -C creds.txt
cat creds.txt
hexdump -C file
hexdump -C -H file
od
od -t x1 -N 10 file
hexdump -C -n 10 file
hexdump -h
hexdump -C -s 10 file
hexdump -C -s 10 creds.txt
vim xor-kpa.py
echo #!/usr/bin/env python\n\n__description__ = 'XOR known-plaintext attack'\n__author__ = 'Didier Stevens'\n__version__ = '0.0.5'\n__date__ = '2017/06/04'\n\n"""\n\nSource code put in public domain by Didier Stevens, no Copyright\nhttps://DidierStevens.com\nUse at your own risk\n\nHistory:\n  2015/12/09: start\n  2015/12/10: continue\n  2015/12/15: continue\n  2016/01/10: 0.0.2 added support for zipfiles\n  2016/08/01: 0.0.3 added support for pipes\n  2016/08/02: added option -n\n  2016/11/08: 0.0.4 added option -x\n  2016/11/16: added key in hex\n  2016/11/18: updated man\n  2017/06/03: 0.0.5 added #e# support; changed output\n  2017/06/04: continued #e# support\n\nTodo:\n  updated man starting changes 2017/06/03\n"""\n\nimport optparse\nimport textwrap\nimport binascii\nimport collections\nimport zipfile\nimport sys\nimport os\nimport re\nimport random\n\nMALWARE_PASSWORD = 'infected'\ndPlaintext = {'dos': 'This program cannot be run in DOS mode'}\n\ndef PrintManual():\n    manual = '''\nManual:\n\nxor-kpa performs a known-plaintext attack (KPA) on an XOR-encoded file. Take a file with content "This is a secret message, do not share!". This file is XOR-encoded like this: the key is ABC, the first byte of the file is XORed with A, the second byte of the file is XORed with B, the third byte of the file is XORed with C, the fourth byte of the file is XORed with A, the fifth byte of the file is XORed with B, ...\nIf you know part of the plaintext of this file, and that plaintext is longer than the key, then xor-kpa can recover the key.\n\nxor-kpa tries to recover the key as follows. xor-kpa encodes the encoded file with the provided plaintext: if you XOR-encode an XOR-encoded file (ciphertext) again with its plaintext, then the result is the keystream (the key repeated): ABCABCABC... xor-kpa detects such keystreams and extracts the key.\n\nExample:\n xor-kpa.py "#secret message" encoded.txt\nOutput:\n Key:       ABC\n Key (hex): 0x414243\n Extra:     11\n Divide:    4\n Counts:    1\n Keystream: BCABCABCABCABC\n\nIn this example, we assume that the plaintext contains "secret message". xor-kpa finds one keystream: BCABCABCABCABC. From this keystream, xor-kpa extracts the key: ABC.\nExtra is the number of extra charecters in the keystream: the keystream is 14 characters longh, the key is 3 characters long, so extra is 14 - 3 = 11. It is a measure for the probability that the recovered key is the actual key. The longer it is, the better.\nIn this case, because the ciphertext is a small file, xor-kpa found only one keystream. But for larger files or small plaintext, it will identify more than one potential keystream.\n\nExample:\n xor-kpa.py #secret encoded.txt\nOutput:\n Key:       'KU\x11W^'\n Key (hex): 0x4b5511575e\n Extra:     1\n Divide:    1\n Counts:    1\n Keystream: '^KU\x11W^'\n\n Key:       '\x07S@E\x1f'\n Key (hex): 0x075340451f\n Extra:     1\n Divide:    1\n Counts:    1\n Keystream: 'S@E\x1f\x07S'\n\n Key:       ABC\n Key (hex): 0x414243\n Extra:     3\n Divide:    2\n Counts:    1\n Keystream: BCABCA\n\nIn this example, xor-kpa has identified 3 potential keys. The potential keys are sorted by ascending extra-value. So the most promising keys are listed last.\nKeystreams with an extra value of 1 (1 extra character) rarely contain the correct key.\nOption -e (--extra) allows us to reduce the amount of displayed potential keys by specifying the minimum value for extras.\n\nExample:\n xor-kpa.py -e 2 #secret encoded.txt\nOutput:\n Key:       ABC\n Key (hex): 0x414243\n Extra:     3\n Keystream: BCABCA\n\nWith option -e 2 we specify that the keystream must at least have 2 extras. That's why the keystreams with 1 extra are not listed.\n\nxor-kpa can also decode the ciphertext file with the recovered key (the key with the highest extra value). Use option -d (--decode) to do this:\n\nExample:\n xor-kpa.py -d #secret encoded.txt\nOutput:\n This is a secret message, do not share!\n\nUsing option -x xor-kpa can encode/decode a message with a provided key.\nExample:\n xor-kpa.py -x #h#152A2A32622A32622261312622302635622E2431302025266D62272E622D2E3663322A22332762 #ABC\nOutput:\n This is a secret message, do not share!\n\nxor-kpa takes one or two arguments. The first argument is a file containing the plaintext, the second argument is a file containing the ciphertext.\nxor-kpa can also read the ciphertext from stdin (for example via a pipe), in that case the second argument is omitted.\nThe files can also be ZIP files containing one file (optionally password-protected with 'infected'), in that case xor-kpa will decompress the content of the ZIP file and use it.\n\nIn stead of putting the plaintext or the ciphertext in a file, it can also be passed in the argument. To achieve this, precede the text with character # (this is what we have done in all the examples up till now).\nIf the text to pass via the argument contains control characters or non-printable characters, hexadecimal (#h#) or base64 (#b#) can be used.\n\nExample:\n xor-kpa.py -d #h#736563726574 encoded.txt\nOutput:\n This is a secret message, do not share!\n\nExample:\n xor-kpa.py -d #b#c2VjcmV0 encoded.txt\nOutput:\n This is a secret message, do not share!\n\nFinally, the plaintext can be selected from a predefined list. For the moment, the only text in the predefined list is 'This program cannot be run in DOS mode', identified by the keyword dos. Use option -n (--name) to use predefined plaintext.\n\nExample:\n xor-kpa.py -n dos malware.vir\n\n'''\n    for line in manual.split('\n'):\n        print(textwrap.fill(line, 78))\n\n#Convert 2 Bytes If Python 3\ndef C2BIP3(string):\n    if sys.version_info[0] > 2:\n        return bytes([ord(x) for x in string])\n    else:\n        return string\n\ndef File2String(filename):\n    try:\n        f = open(filename, 'rb')\n    except:\n        return None\n    try:\n        return f.read()\n    except:\n        return None\n    finally:\n        f.close()\n\ndef LoremIpsumSentence(minimum, maximum):\n    words = ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit', 'etiam', 'tortor', 'metus', 'cursus', 'sed', 'sollicitudin', 'ac', 'sagittis', 'eget', 'massa', 'praesent', 'sem', 'fermentum', 'dignissim', 'in', 'vel', 'augue', 'scelerisque', 'auctor', 'libero', 'nam', 'a', 'gravida', 'odio', 'duis', 'vestibulum', 'vulputate', 'quam', 'nec', 'cras', 'nibh', 'feugiat', 'ut', 'vitae', 'ornare', 'justo', 'orci', 'varius', 'natoque', 'penatibus', 'et', 'magnis', 'dis', 'parturient', 'montes', 'nascetur', 'ridiculus', 'mus', 'curabitur', 'nisl', 'egestas', 'urna', 'iaculis', 'lectus', 'maecenas', 'ultrices', 'velit', 'eu', 'porta', 'hac', 'habitasse', 'platea', 'dictumst', 'integer', 'id', 'commodo', 'mauris', 'interdum', 'malesuada', 'fames', 'ante', 'primis', 'faucibus', 'accumsan', 'pharetra', 'aliquam', 'nunc', 'at', 'est', 'non', 'leo', 'nulla', 'sodales', 'porttitor', 'facilisis', 'aenean', 'condimentum', 'rutrum', 'facilisi', 'tincidunt', 'laoreet', 'ultricies', 'neque', 'diam', 'euismod', 'consequat', 'tempor', 'elementum', 'lobortis', 'erat', 'ligula', 'risus', 'donec', 'phasellus', 'quisque', 'vivamus', 'pellentesque', 'tristique', 'venenatis', 'purus', 'mi', 'dictum', 'posuere', 'fringilla', 'quis', 'magna', 'pretium', 'felis', 'pulvinar', 'lacinia', 'proin', 'viverra', 'lacus', 'suscipit', 'aliquet', 'dui', 'molestie', 'dapibus', 'mollis', 'suspendisse', 'sapien', 'blandit', 'morbi', 'tellus', 'enim', 'maximus', 'semper', 'arcu', 'bibendum', 'convallis', 'hendrerit', 'imperdiet', 'finibus', 'fusce', 'congue', 'ullamcorper', 'placerat', 'nullam', 'eros', 'habitant', 'senectus', 'netus', 'turpis', 'luctus', 'volutpat', 'rhoncus', 'mattis', 'nisi', 'ex', 'tempus', 'eleifend', 'vehicula', 'class', 'aptent', 'taciti', 'sociosqu', 'ad', 'litora', 'torquent', 'per', 'conubia', 'nostra', 'inceptos', 'himenaeos']\n    sample = random.sample(words, random.randint(minimum, maximum))\n    sample[0] = sample[0].capitalize()\n    return ' '.join(sample) + '.'\n\ndef LoremIpsum(sentences):\n    return ' '.join([LoremIpsumSentence(15, 30) for i in range(sentences)])\n\ndef FilenameCheckHashExpression(expression):\n    oMatch = re.match(r'repeat\((\d+),(0x[0-9a-fA-F]+)\)$', expression)\n    if oMatch != None:\n        try:\n            return int(oMatch.groups()[0]) * binascii.a2b_hex(oMatch.groups()[1][2:])\n        except:\n            return None\n    else:\n        oMatch = re.match(r'random\((\d+)\)$', expression)\n        if oMatch != None:\n            try:\n                return ''.join([chr(random.randint(0, 255)) for x in range(int(oMatch.groups()[0]))])\n            except:\n                return None\n        else:\n            oMatch = re.match(r'loremipsum\((\d+)\)$', expression)\n            if oMatch != None:\n                try:\n                    return LoremIpsum(int(oMatch.groups()[0]))\n                except:\n                    return None\n            else:\n                return None\n\ndef FilenameCheckHash(filename):\n    decoded = None\n    if filename.startswith('#h#'):\n        try:\n            decoded = binascii.a2b_hex(filename[3:])\n        finally:\n            return decoded\n    elif filename.startswith('#b#'):\n        try:\n            decoded = binascii.a2b_base64(filename[3:])\n        finally:\n            return decoded\n    elif filename.startswith('#e#'):\n        decoded = ''\n        for expression in filename[3:].split('+'):\n            result = FilenameCheckHashExpression(expression)\n            if result == None:\n                return None\n            else:\n                decoded += result\n        return decoded\n    elif filename.startswith('#'):\n        return filename[1:]\n    else:\n        return ''\n\ndef File2StringHash(filename):\n    decoded = FilenameCheckHash(filename)\n    if decoded != '':\n        return decoded\n    elif filename.lower().endswith('.zip'):\n        oZipfile = zipfile.ZipFile(filename, 'r')\n        if len(oZipfile.infolist()) == 1:\n            oZipContent = oZipfile.open(oZipfile.infolist()[0], 'r', C2BIP3(MALWARE_PASSWORD))\n            data = oZipContent.read()\n            oZipContent.close()\n        else:\n            data = File2String(filename)\n        oZipfile.close()\n        return data\n    else:\n        return File2String(filename)\n\ndef IfWIN32SetBinary(io):\n    if sys.platform == 'win32':\n        import msvcrt\n        msvcrt.setmode(io.fileno(), os.O_BINARY)\n\n#Fix for http://bugs.python.org/issue11395\ndef StdoutWriteChunked(data):\n    while data != '':\n        sys.stdout.write(data[0:10000])\n        try:\n            sys.stdout.flush()\n        except IOError:\n            return\n        data = data[10000:]\n\ndef ReprIfNeeded(data):\n    if "'" + data + "'" == repr(data):\n        return data\n    else:\n        return repr(data)\n\nclass cPrintSeparatingLine():\n    def __init__(self):\n        self.first = True\n        \n    def Print(self, line=''):\n        if self.first:\n            self.first = False\n        else:\n            print(line)\n\ndef XORData(data, key):\n    return ''.join([chr(ord(data[i]) ^ ord(key[i % len(key)])) for i in range(len(data))])\n\ndef SplitKey(extractedKeyStream):\n    result = []\n    for i in range(2, len(extractedKeyStream)):\n        temp = extractedKeyStream\n        keys = []\n        while temp != '':\n            keys.append(temp[0:i])\n            temp = temp[i:]\n        result.append(keys)\n    return result\n\ndef FilterKeys(keyss):\n    result = []\n    for keys in keyss:\n        while len(keys) > 2 and keys[0] == keys[1]:\n            keys = keys[1:]\n        if len(keys) == 2 and keys[0][0:len(keys[1])] == keys[1]:\n            result.append(keys[0])\n\n    while len(result) > 1:\n        if result[0] * (len(result[1]) / len(result[0])) == result[1]:\n            del result[1]\n        else:\n            break\n\n    return result\n\ndef XOR(filenamePlaintext, filenameCiphertext, options):\n    global dPlaintext\n\n    nKeydata = collections.namedtuple('keydata', 'extra keystream key')\n\n    if options.name:\n        if filenamePlaintext.lower() in dPlaintext:\n            plaintext = dPlaintext[filenamePlaintext.lower()]\n        else:\n            print('Unknown name for plaintext: %s' % options.name)\n            return\n    else:\n        plaintext = File2StringHash(filenamePlaintext)\n        if plaintext == None:\n            print('Error reading: %s' % filenamePlaintext)\n            return\n    if filenameCiphertext == '':\n        IfWIN32SetBinary(sys.stdin)\n        ciphertext = sys.stdin.read()\n    else:\n        ciphertext = File2StringHash(filenameCiphertext)\n        if ciphertext == None:\n            print('Error reading: %s' % filenameCiphertext)\n            return\n\n    if options.xor:\n        IfWIN32SetBinary(sys.stdout)\n        StdoutWriteChunked(XORData(plaintext, ciphertext))\n        return\n\n    results = []\n    for i in range(len(ciphertext) - len(plaintext)):\n        extractedKeyStream = XORData(plaintext, ciphertext[i:])\n        keys = FilterKeys(SplitKey(extractedKeyStream))\n        if len(keys) == 1:\n            key = keys[0]\n            start = len(key) - i % len(key)\n            results.append(nKeydata(len(extractedKeyStream) - len(keys[0]), extractedKeyStream, key[start:] + key[0:start]))\n        elif len(keys) > 1 and options.verbose:\n            print('Found more than one repeating key in key stream')\n            print('Extracted key stream: %s' % repr(extractedKeyStream))\n            print(keys)\n\n    results = [result for result in results if result.extra >= options.extra]\n    if len(results) == 0:\n        print('No key found')\n        return\n\n    dKeys = {}\n    reduced = []\n    for result in sorted(results, key=lambda x: x.extra, reverse=True):\n        if result.key in dKeys:\n            dKeys[result.key] += 1\n        else:\n            dKeys[result.key] = 1\n            reduced.insert(0, result)\n    if options.decode:\n        IfWIN32SetBinary(sys.stdout)\n        StdoutWriteChunked(XORData(ciphertext, reduced[-1].key))\n    else:\n        oPrintSeparatingLine = cPrintSeparatingLine()\n        for result in reduced:\n            oPrintSeparatingLine.Print()\n            print('Key:       %s' % ReprIfNeeded(result.key))\n            print('Key (hex): 0x%s' % binascii.b2a_hex(result.key))\n            print('Extra:     %s' % result.extra)\n            print('Divide:    %d' % (len(result.keystream) / len(result.key)))\n            print('Counts:    %d' % dKeys[result.key])\n            print('Keystream: %s' % ReprIfNeeded(result.keystream))\n\ndef Main():\n    global dPlaintext\n\n    moredesc = '''\n\nPredefined plaintext:\n'''\n\n    for key in sorted(dPlaintext.keys()):\n        moredesc += ' %s: %s\n' % (key, dPlaintext[key])\n\n    moredesc += '''\nSource code put in the public domain by Didier Stevens, no Copyright\nUse at your own risk\nhttps://DidierStevens.com'''\n\n    oParser = optparse.OptionParser(usage='usage: %prog [options] filename-plaintext [filename-ciphertext]\n' + __description__ + moredesc, version='%prog ' + __version__)\n    oParser.add_option('-m', '--man', action='store_true', default=False, help='Print manual')\n    oParser.add_option('-n', '--name', action='store_true', default=False, help='Use predefined plaintext')\n    oParser.add_option('-e', '--extra', type=int, default=1, help='Minimum number of extras')\n    oParser.add_option('-d', '--decode', action='store_true', default=False, help='Decode the ciphertext')\n    oParser.add_option('-x', '--xor', action='store_true', default=False, help='XOR data with key')\n    oParser.add_option('-v', '--verbose', action='store_true', default=False, help='Verbose output')\n    (options, args) = oParser.parse_args()\n\n    if options.man:\n        oParser.print_help()\n        PrintManual()\n        return\n\n    if len(args) != 1 and len(args) != 2:\n        oParser.print_help()\n        print('')\n        print('  Source code put in the public domain by Didier Stevens, no Copyright')\n        print('  Use at your own risk')\n        print('  https://DidierStevens.com')\n        return\n    elif len(args) == 1:\n        XOR(args[0], '', options)\n    else:\n        XOR(args[0], args[1], options)\n\nif __name__ == '__main__':\n    Main() 
nvim xor-kpa.py
hexdump -C -s 10 creds.txt
ls
mv xor-kpa.py ../userDecrypt/ .
cd -
cd ../user
cd ..
ls
ls -la
cd userDecrypt
mv ../xor-kpa.py .
nvim xor-kpa.py
hexdump -C -s 10 creds.txt
hexdump -C -s 9 creds.txt
hexdump -C  creds.txt
hexdump -C  file
hexdump -C -s 10 creds.txt
hexdump -C -s 12 creds.txt
hexdump -C -s 12 creds.txt > creds.hex
cat creds.hex
hexdump -s 12 creds.txt > creds.hex
cat creds.hex
hexdump creds.hex
hexdump creds.hex fc -lLn -64 > '/root/.tmux/resurrect/zsh_history-HTB:5.1'
hexdump -C creds.hex
readelf creds.txt
hexdump -s 12 creds.txt > creds.hex
hexdump -C -s 12 creds.txt
hexdump -h
xxd -p -l 10 -seek 10 creds.txt
xxd -p -l 10 -seek 10 creds.txt > creds.hex
hexdump creds.hex
hexdump -C creds.hex
hexdump -C creds.txt
xxd -p creds.txt
ls
vim dict
python3 xor-kpa.py dict creds.txt
python xor-kpa.py dict creds.txt
dd if=creds.txt of=creds.dump ibs=12 skip=1
ls
hexdump -C creds.
hexdump -C creds.dump
python xor-kpa.py dict creds.dump
hexdump -C creds.dump
hexdump -C creds.txt
